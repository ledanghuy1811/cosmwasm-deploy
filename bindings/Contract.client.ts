/**
* This file was automatically generated by @oraichain/ts-codegen@0.35.8.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @oraichain/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import {Uint128, InstantiateMsg, Coin, ExecuteMsg, PublicSignal, QueryMsg, ConfigResponse, LatestUserReceivedSignalResponse, PrivateSignalResponse, ProviderSignalFeeResponse, PublicSignalResponse, TemporaryPrivateSignalsResponse, UserReceivedSignalsResponse} from "./Contract.types";
export interface ContractReadOnlyInterface {
  contractAddress: string;
  config: () => Promise<ConfigResponse>;
  publicSignal: ({
    provider
  }: {
    provider: string;
  }) => Promise<PublicSignalResponse>;
  privateSignal: ({
    provider
  }: {
    provider: string;
  }) => Promise<PrivateSignalResponse>;
  providerSignalFee: ({
    provider
  }: {
    provider: string;
  }) => Promise<ProviderSignalFeeResponse>;
  userReceivedSignals: ({
    provider,
    user
  }: {
    provider: string;
    user: string;
  }) => Promise<UserReceivedSignalsResponse>;
  latestUserReceivedSignal: ({
    provider,
    user
  }: {
    provider: string;
    user: string;
  }) => Promise<LatestUserReceivedSignalResponse>;
  temporaryPrivateSignals: ({
    provider
  }: {
    provider: string;
  }) => Promise<TemporaryPrivateSignalsResponse>;
}
export class ContractQueryClient implements ContractReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.config = this.config.bind(this);
    this.publicSignal = this.publicSignal.bind(this);
    this.privateSignal = this.privateSignal.bind(this);
    this.providerSignalFee = this.providerSignalFee.bind(this);
    this.userReceivedSignals = this.userReceivedSignals.bind(this);
    this.latestUserReceivedSignal = this.latestUserReceivedSignal.bind(this);
    this.temporaryPrivateSignals = this.temporaryPrivateSignals.bind(this);
  }

  config = async (): Promise<ConfigResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      config: {}
    });
  };
  publicSignal = async ({
    provider
  }: {
    provider: string;
  }): Promise<PublicSignalResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      public_signal: {
        provider
      }
    });
  };
  privateSignal = async ({
    provider
  }: {
    provider: string;
  }): Promise<PrivateSignalResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      private_signal: {
        provider
      }
    });
  };
  providerSignalFee = async ({
    provider
  }: {
    provider: string;
  }): Promise<ProviderSignalFeeResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      provider_signal_fee: {
        provider
      }
    });
  };
  userReceivedSignals = async ({
    provider,
    user
  }: {
    provider: string;
    user: string;
  }): Promise<UserReceivedSignalsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      user_received_signals: {
        provider,
        user
      }
    });
  };
  latestUserReceivedSignal = async ({
    provider,
    user
  }: {
    provider: string;
    user: string;
  }): Promise<LatestUserReceivedSignalResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      latest_user_received_signal: {
        provider,
        user
      }
    });
  };
  temporaryPrivateSignals = async ({
    provider
  }: {
    provider: string;
  }): Promise<TemporaryPrivateSignalsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      temporary_private_signals: {
        provider
      }
    });
  };
}
export interface ContractInterface extends ContractReadOnlyInterface {
  contractAddress: string;
  sender: string;
  sendPublicSignal: ({
    provider,
    signal
  }: {
    provider: string;
    signal: PublicSignal;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  sendPrivateSignal: ({
    provider,
    signalHash
  }: {
    provider: string;
    signalHash: string;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  registerToBeProvider: (_fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  changeOwner: ({
    newOwner
  }: {
    newOwner: string;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  changeFeeProvider: ({
    newFee
  }: {
    newFee: Coin;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  addOrRemoveProvider: ({
    changeState,
    providers
  }: {
    changeState: boolean;
    providers: string[];
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setProviderSignalFee: ({
    fee
  }: {
    fee: Coin;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  requestLatestSignalFromProvider: ({
    provider,
    userPublicKey
  }: {
    provider: string;
    userPublicKey: string;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  sendSignalEncryptedToUser: ({
    encryptedSignal,
    user
  }: {
    encryptedSignal: string;
    user: string;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class ContractClient extends ContractQueryClient implements ContractInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.sendPublicSignal = this.sendPublicSignal.bind(this);
    this.sendPrivateSignal = this.sendPrivateSignal.bind(this);
    this.registerToBeProvider = this.registerToBeProvider.bind(this);
    this.changeOwner = this.changeOwner.bind(this);
    this.changeFeeProvider = this.changeFeeProvider.bind(this);
    this.addOrRemoveProvider = this.addOrRemoveProvider.bind(this);
    this.setProviderSignalFee = this.setProviderSignalFee.bind(this);
    this.requestLatestSignalFromProvider = this.requestLatestSignalFromProvider.bind(this);
    this.sendSignalEncryptedToUser = this.sendSignalEncryptedToUser.bind(this);
  }

  sendPublicSignal = async ({
    provider,
    signal
  }: {
    provider: string;
    signal: PublicSignal;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      send_public_signal: {
        provider,
        signal
      }
    }, _fee, _memo, _funds);
  };
  sendPrivateSignal = async ({
    provider,
    signalHash
  }: {
    provider: string;
    signalHash: string;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      send_private_signal: {
        provider,
        signal_hash: signalHash
      }
    }, _fee, _memo, _funds);
  };
  registerToBeProvider = async (_fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      register_to_be_provider: {}
    }, _fee, _memo, _funds);
  };
  changeOwner = async ({
    newOwner
  }: {
    newOwner: string;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      change_owner: {
        new_owner: newOwner
      }
    }, _fee, _memo, _funds);
  };
  changeFeeProvider = async ({
    newFee
  }: {
    newFee: Coin;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      change_fee_provider: {
        new_fee: newFee
      }
    }, _fee, _memo, _funds);
  };
  addOrRemoveProvider = async ({
    changeState,
    providers
  }: {
    changeState: boolean;
    providers: string[];
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_or_remove_provider: {
        change_state: changeState,
        providers
      }
    }, _fee, _memo, _funds);
  };
  setProviderSignalFee = async ({
    fee
  }: {
    fee: Coin;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_provider_signal_fee: {
        fee
      }
    }, _fee, _memo, _funds);
  };
  requestLatestSignalFromProvider = async ({
    provider,
    userPublicKey
  }: {
    provider: string;
    userPublicKey: string;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      request_latest_signal_from_provider: {
        provider,
        user_public_key: userPublicKey
      }
    }, _fee, _memo, _funds);
  };
  sendSignalEncryptedToUser = async ({
    encryptedSignal,
    user
  }: {
    encryptedSignal: string;
    user: string;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      send_signal_encrypted_to_user: {
        encrypted_signal: encryptedSignal,
        user
      }
    }, _fee, _memo, _funds);
  };
}