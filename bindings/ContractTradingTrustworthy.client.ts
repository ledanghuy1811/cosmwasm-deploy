/**
* This file was automatically generated by @oraichain/ts-codegen@0.35.9.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @oraichain/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import {Uint128, InstantiateMsg, Coin, ExecuteMsg, PublicSignal, QueryMsg, ArrayOfAllUserReceiveSignalsResponse, AllUserReceiveSignalsResponse, ConfigResponse, LatestUserReceivedSignalResponse, UserReceiveSignal, Addr, ProviderInfoResponse, ProviderInfo, PublicSignalResponse, PublicSignalInfo, Timestamp, Uint64, RequestEncryptedUserResponse, RequestEncryptedInfo, TempSignalWithRequestResponse, TempSignalRequestInfo, TemporaryPrivateSignalInfo, PriceInfo, TemporarySignalInfoResponse, UserReceivedSignalsResponse} from "./ContractTradingTrustworthy.types";
export interface ContractTradingTrustworthyReadOnlyInterface {
  contractAddress: string;
  config: () => Promise<ConfigResponse>;
  publicSignal: ({
    provider
  }: {
    provider: string;
  }) => Promise<PublicSignalResponse>;
  temporarySignalInfo: ({
    provider
  }: {
    provider: string;
  }) => Promise<TemporarySignalInfoResponse>;
  requestEncryptedInfo: ({
    provider,
    signalHash
  }: {
    provider: string;
    signalHash: string;
  }) => Promise<RequestEncryptedUserResponse>;
  providerInfo: ({
    provider
  }: {
    provider: string;
  }) => Promise<ProviderInfoResponse>;
  userReceivedSignals: ({
    provider,
    user
  }: {
    provider: string;
    user: string;
  }) => Promise<UserReceivedSignalsResponse>;
  latestUserReceivedSignal: ({
    provider,
    user
  }: {
    provider: string;
    user: string;
  }) => Promise<LatestUserReceivedSignalResponse>;
  tempSignalWithRequest: ({
    provider
  }: {
    provider?: string;
  }) => Promise<TempSignalWithRequestResponse>;
  allUserReceiveSignal: ({
    user
  }: {
    user: string;
  }) => Promise<ArrayOfAllUserReceiveSignalsResponse>;
}
export class ContractTradingTrustworthyQueryClient implements ContractTradingTrustworthyReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.config = this.config.bind(this);
    this.publicSignal = this.publicSignal.bind(this);
    this.temporarySignalInfo = this.temporarySignalInfo.bind(this);
    this.requestEncryptedInfo = this.requestEncryptedInfo.bind(this);
    this.providerInfo = this.providerInfo.bind(this);
    this.userReceivedSignals = this.userReceivedSignals.bind(this);
    this.latestUserReceivedSignal = this.latestUserReceivedSignal.bind(this);
    this.tempSignalWithRequest = this.tempSignalWithRequest.bind(this);
    this.allUserReceiveSignal = this.allUserReceiveSignal.bind(this);
  }

  config = async (): Promise<ConfigResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      config: {}
    });
  };
  publicSignal = async ({
    provider
  }: {
    provider: string;
  }): Promise<PublicSignalResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      public_signal: {
        provider
      }
    });
  };
  temporarySignalInfo = async ({
    provider
  }: {
    provider: string;
  }): Promise<TemporarySignalInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      temporary_signal_info: {
        provider
      }
    });
  };
  requestEncryptedInfo = async ({
    provider,
    signalHash
  }: {
    provider: string;
    signalHash: string;
  }): Promise<RequestEncryptedUserResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      request_encrypted_info: {
        provider,
        signal_hash: signalHash
      }
    });
  };
  providerInfo = async ({
    provider
  }: {
    provider: string;
  }): Promise<ProviderInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      provider_info: {
        provider
      }
    });
  };
  userReceivedSignals = async ({
    provider,
    user
  }: {
    provider: string;
    user: string;
  }): Promise<UserReceivedSignalsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      user_received_signals: {
        provider,
        user
      }
    });
  };
  latestUserReceivedSignal = async ({
    provider,
    user
  }: {
    provider: string;
    user: string;
  }): Promise<LatestUserReceivedSignalResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      latest_user_received_signal: {
        provider,
        user
      }
    });
  };
  tempSignalWithRequest = async ({
    provider
  }: {
    provider?: string;
  }): Promise<TempSignalWithRequestResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      temp_signal_with_request: {
        provider
      }
    });
  };
  allUserReceiveSignal = async ({
    user
  }: {
    user: string;
  }): Promise<ArrayOfAllUserReceiveSignalsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      all_user_receive_signal: {
        user
      }
    });
  };
}
export interface ContractTradingTrustworthyInterface extends ContractTradingTrustworthyReadOnlyInterface {
  contractAddress: string;
  sender: string;
  registerToBeProvider: ({
    avatar,
    banner,
    description,
    fee,
    name
  }: {
    avatar?: string;
    banner?: string;
    description: string;
    fee: Coin;
    name: string;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  sendPrivateSignal: ({
    signalHash,
    token
  }: {
    signalHash: string;
    token: string;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  sendPublicSignal: ({
    signal,
    signalHash
  }: {
    signal: PublicSignal;
    signalHash: string;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  requestSignalFromProvider: ({
    provider,
    signalHash,
    userPublicKey
  }: {
    provider: string;
    signalHash: string;
    userPublicKey: string;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  sendSignalEncryptedToUser: ({
    encryptedSignal,
    user
  }: {
    encryptedSignal: string;
    user: string;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  changeOwner: ({
    newOwner
  }: {
    newOwner: string;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  changeFeeProvider: ({
    newFee
  }: {
    newFee: Coin;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setProviderSignalFee: ({
    fee
  }: {
    fee: Coin;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  changePriceOracle: ({
    newPriceOracle
  }: {
    newPriceOracle: string;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class ContractTradingTrustworthyClient extends ContractTradingTrustworthyQueryClient implements ContractTradingTrustworthyInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.registerToBeProvider = this.registerToBeProvider.bind(this);
    this.sendPrivateSignal = this.sendPrivateSignal.bind(this);
    this.sendPublicSignal = this.sendPublicSignal.bind(this);
    this.requestSignalFromProvider = this.requestSignalFromProvider.bind(this);
    this.sendSignalEncryptedToUser = this.sendSignalEncryptedToUser.bind(this);
    this.changeOwner = this.changeOwner.bind(this);
    this.changeFeeProvider = this.changeFeeProvider.bind(this);
    this.setProviderSignalFee = this.setProviderSignalFee.bind(this);
    this.changePriceOracle = this.changePriceOracle.bind(this);
  }

  registerToBeProvider = async ({
    avatar,
    banner,
    description,
    fee,
    name
  }: {
    avatar?: string;
    banner?: string;
    description: string;
    fee: Coin;
    name: string;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      register_to_be_provider: {
        avatar,
        banner,
        description,
        fee,
        name
      }
    }, _fee, _memo, _funds);
  };
  sendPrivateSignal = async ({
    signalHash,
    token
  }: {
    signalHash: string;
    token: string;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      send_private_signal: {
        signal_hash: signalHash,
        token
      }
    }, _fee, _memo, _funds);
  };
  sendPublicSignal = async ({
    signal,
    signalHash
  }: {
    signal: PublicSignal;
    signalHash: string;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      send_public_signal: {
        signal,
        signal_hash: signalHash
      }
    }, _fee, _memo, _funds);
  };
  requestSignalFromProvider = async ({
    provider,
    signalHash,
    userPublicKey
  }: {
    provider: string;
    signalHash: string;
    userPublicKey: string;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      request_signal_from_provider: {
        provider,
        signal_hash: signalHash,
        user_public_key: userPublicKey
      }
    }, _fee, _memo, _funds);
  };
  sendSignalEncryptedToUser = async ({
    encryptedSignal,
    user
  }: {
    encryptedSignal: string;
    user: string;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      send_signal_encrypted_to_user: {
        encrypted_signal: encryptedSignal,
        user
      }
    }, _fee, _memo, _funds);
  };
  changeOwner = async ({
    newOwner
  }: {
    newOwner: string;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      change_owner: {
        new_owner: newOwner
      }
    }, _fee, _memo, _funds);
  };
  changeFeeProvider = async ({
    newFee
  }: {
    newFee: Coin;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      change_fee_provider: {
        new_fee: newFee
      }
    }, _fee, _memo, _funds);
  };
  setProviderSignalFee = async ({
    fee
  }: {
    fee: Coin;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_provider_signal_fee: {
        fee
      }
    }, _fee, _memo, _funds);
  };
  changePriceOracle = async ({
    newPriceOracle
  }: {
    newPriceOracle: string;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      change_price_oracle: {
        new_price_oracle: newPriceOracle
      }
    }, _fee, _memo, _funds);
  };
}