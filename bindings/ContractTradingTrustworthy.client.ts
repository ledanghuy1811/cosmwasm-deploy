/**
* This file was automatically generated by @oraichain/ts-codegen@0.35.9.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @oraichain/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import {Uint128, InstantiateMsg, Coin, ExecuteMsg, PublicSignal, QueryMsg, ConfigResponse, LatestUserReceivedSignalResponse, PrivateSignalResponse, ProviderSignalFeeResponse, PublicSignalResponse, Timestamp, Uint64, RequestEncryptedUserResponse, RequestEncryptedInfo, TemporaryPrivateSignalsResponse, TokenPriceInfoResponse, PriceInfo, UserReceivedSignalsResponse} from "./ContractTradingTrustworthy.types";
export interface ContractTradingTrustworthyReadOnlyInterface {
  contractAddress: string;
  config: () => Promise<ConfigResponse>;
  publicSignal: ({
    provider
  }: {
    provider: string;
  }) => Promise<PublicSignalResponse>;
  privateSignal: ({
    provider
  }: {
    provider: string;
  }) => Promise<PrivateSignalResponse>;
  providerSignalFee: ({
    provider
  }: {
    provider: string;
  }) => Promise<ProviderSignalFeeResponse>;
  userReceivedSignals: ({
    provider,
    user
  }: {
    provider: string;
    user: string;
  }) => Promise<UserReceivedSignalsResponse>;
  latestUserReceivedSignal: ({
    provider,
    user
  }: {
    provider: string;
    user: string;
  }) => Promise<LatestUserReceivedSignalResponse>;
  temporaryPrivateSignals: ({
    provider
  }: {
    provider: string;
  }) => Promise<TemporaryPrivateSignalsResponse>;
  requestEncryptedInfo: ({
    provider,
    signalHash
  }: {
    provider: string;
    signalHash: string;
  }) => Promise<RequestEncryptedUserResponse>;
  tokenPriceInfo: ({
    signalHash
  }: {
    signalHash: string;
  }) => Promise<TokenPriceInfoResponse>;
}
export class ContractTradingTrustworthyQueryClient implements ContractTradingTrustworthyReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.config = this.config.bind(this);
    this.publicSignal = this.publicSignal.bind(this);
    this.privateSignal = this.privateSignal.bind(this);
    this.providerSignalFee = this.providerSignalFee.bind(this);
    this.userReceivedSignals = this.userReceivedSignals.bind(this);
    this.latestUserReceivedSignal = this.latestUserReceivedSignal.bind(this);
    this.temporaryPrivateSignals = this.temporaryPrivateSignals.bind(this);
    this.requestEncryptedInfo = this.requestEncryptedInfo.bind(this);
    this.tokenPriceInfo = this.tokenPriceInfo.bind(this);
  }

  config = async (): Promise<ConfigResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      config: {}
    });
  };
  publicSignal = async ({
    provider
  }: {
    provider: string;
  }): Promise<PublicSignalResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      public_signal: {
        provider
      }
    });
  };
  privateSignal = async ({
    provider
  }: {
    provider: string;
  }): Promise<PrivateSignalResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      private_signal: {
        provider
      }
    });
  };
  providerSignalFee = async ({
    provider
  }: {
    provider: string;
  }): Promise<ProviderSignalFeeResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      provider_signal_fee: {
        provider
      }
    });
  };
  userReceivedSignals = async ({
    provider,
    user
  }: {
    provider: string;
    user: string;
  }): Promise<UserReceivedSignalsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      user_received_signals: {
        provider,
        user
      }
    });
  };
  latestUserReceivedSignal = async ({
    provider,
    user
  }: {
    provider: string;
    user: string;
  }): Promise<LatestUserReceivedSignalResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      latest_user_received_signal: {
        provider,
        user
      }
    });
  };
  temporaryPrivateSignals = async ({
    provider
  }: {
    provider: string;
  }): Promise<TemporaryPrivateSignalsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      temporary_private_signals: {
        provider
      }
    });
  };
  requestEncryptedInfo = async ({
    provider,
    signalHash
  }: {
    provider: string;
    signalHash: string;
  }): Promise<RequestEncryptedUserResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      request_encrypted_info: {
        provider,
        signal_hash: signalHash
      }
    });
  };
  tokenPriceInfo = async ({
    signalHash
  }: {
    signalHash: string;
  }): Promise<TokenPriceInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      token_price_info: {
        signal_hash: signalHash
      }
    });
  };
}
export interface ContractTradingTrustworthyInterface extends ContractTradingTrustworthyReadOnlyInterface {
  contractAddress: string;
  sender: string;
  sendPublicSignal: ({
    signal
  }: {
    signal: PublicSignal;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  sendPrivateSignal: ({
    signalHash
  }: {
    signalHash: string;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  registerToBeProvider: (_fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  changeOwner: ({
    newOwner
  }: {
    newOwner: string;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  changeFeeProvider: ({
    newFee
  }: {
    newFee: Coin;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  addOrRemoveProvider: ({
    changeState,
    providers
  }: {
    changeState: boolean;
    providers: string[];
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setProviderSignalFee: ({
    fee
  }: {
    fee: Coin;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  requestLatestSignalFromProvider: ({
    provider,
    signalHash,
    userPublicKey
  }: {
    provider: string;
    signalHash: string;
    userPublicKey: string;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  sendSignalEncryptedToUser: ({
    encryptedSignal,
    user
  }: {
    encryptedSignal: string;
    user: string;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  claimFeeFromProvider: ({
    provider,
    signalHash
  }: {
    provider: string;
    signalHash: string;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  changeOracleAddress: ({
    newOracle
  }: {
    newOracle: string;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class ContractTradingTrustworthyClient extends ContractTradingTrustworthyQueryClient implements ContractTradingTrustworthyInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.sendPublicSignal = this.sendPublicSignal.bind(this);
    this.sendPrivateSignal = this.sendPrivateSignal.bind(this);
    this.registerToBeProvider = this.registerToBeProvider.bind(this);
    this.changeOwner = this.changeOwner.bind(this);
    this.changeFeeProvider = this.changeFeeProvider.bind(this);
    this.addOrRemoveProvider = this.addOrRemoveProvider.bind(this);
    this.setProviderSignalFee = this.setProviderSignalFee.bind(this);
    this.requestLatestSignalFromProvider = this.requestLatestSignalFromProvider.bind(this);
    this.sendSignalEncryptedToUser = this.sendSignalEncryptedToUser.bind(this);
    this.claimFeeFromProvider = this.claimFeeFromProvider.bind(this);
    this.changeOracleAddress = this.changeOracleAddress.bind(this);
  }

  sendPublicSignal = async ({
    signal
  }: {
    signal: PublicSignal;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      send_public_signal: {
        signal
      }
    }, _fee, _memo, _funds);
  };
  sendPrivateSignal = async ({
    signalHash
  }: {
    signalHash: string;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      send_private_signal: {
        signal_hash: signalHash
      }
    }, _fee, _memo, _funds);
  };
  registerToBeProvider = async (_fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      register_to_be_provider: {}
    }, _fee, _memo, _funds);
  };
  changeOwner = async ({
    newOwner
  }: {
    newOwner: string;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      change_owner: {
        new_owner: newOwner
      }
    }, _fee, _memo, _funds);
  };
  changeFeeProvider = async ({
    newFee
  }: {
    newFee: Coin;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      change_fee_provider: {
        new_fee: newFee
      }
    }, _fee, _memo, _funds);
  };
  addOrRemoveProvider = async ({
    changeState,
    providers
  }: {
    changeState: boolean;
    providers: string[];
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_or_remove_provider: {
        change_state: changeState,
        providers
      }
    }, _fee, _memo, _funds);
  };
  setProviderSignalFee = async ({
    fee
  }: {
    fee: Coin;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_provider_signal_fee: {
        fee
      }
    }, _fee, _memo, _funds);
  };
  requestLatestSignalFromProvider = async ({
    provider,
    signalHash,
    userPublicKey
  }: {
    provider: string;
    signalHash: string;
    userPublicKey: string;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      request_latest_signal_from_provider: {
        provider,
        signal_hash: signalHash,
        user_public_key: userPublicKey
      }
    }, _fee, _memo, _funds);
  };
  sendSignalEncryptedToUser = async ({
    encryptedSignal,
    user
  }: {
    encryptedSignal: string;
    user: string;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      send_signal_encrypted_to_user: {
        encrypted_signal: encryptedSignal,
        user
      }
    }, _fee, _memo, _funds);
  };
  claimFeeFromProvider = async ({
    provider,
    signalHash
  }: {
    provider: string;
    signalHash: string;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      claim_fee_from_provider: {
        provider,
        signal_hash: signalHash
      }
    }, _fee, _memo, _funds);
  };
  changeOracleAddress = async ({
    newOracle
  }: {
    newOracle: string;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      change_oracle_address: {
        new_oracle: newOracle
      }
    }, _fee, _memo, _funds);
  };
}